#
# This file was initially generated by a Large Language Model (Gemini) 
# to create a Streamlit interactive application based on my project.
# The core logic and algorithms are entirely my own.
#
import streamlit as st
import numpy as np
import random
import time

# --- STREAMLIT SETUP ---
st.set_page_config(page_title="Schelling's Model", layout="wide")
st.title("Interactive Schelling's Model")

# --- CONSTANTS (Fixed) ---
GRID_SIZE = 100
EMPTY_HOUSE_RATIO = 0.025
BLUE_PARTY_RATIO = 0.5
ANIMATION_SPEED = 0.0

# Derived constants
RED_PARTY_RATIO = 1 - BLUE_PARTY_RATIO
BLUE_EFFECTIVE_RATIO = (1 - EMPTY_HOUSE_RATIO) * BLUE_PARTY_RATIO
RED_EFFECTIVE_RATIO = (1 - EMPTY_HOUSE_RATIO) * RED_PARTY_RATIO

# Integer constants
EMPTY = 0
BLUE = 1
RED = 2
HIGHWAY = 3

# --- SIDEBAR INPUTS ---
st.sidebar.header("Parameters")

RELOCATION_THRESHOLD = st.sidebar.slider("Relocation Threshold", 0.0, 1.0, 0.4)
use_highway = st.sidebar.checkbox("Add Highway", value=False)

# --- ALGORITHM FUNCTIONS ---

def identify(grid):
    unhappy_agents = []
    empty_spots = []
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if grid[row][col] != EMPTY and grid[row][col] != HIGHWAY:
                total_neighbors = 0
                bad_neighbors = 0
                for neighbor_row in range(max(0, row-1), min(GRID_SIZE, row+2)):
                    for neighbor_col in range(max(0, col-1), min(GRID_SIZE, col+2)):
                        if(neighbor_row != row or neighbor_col != col):
                            if(grid[neighbor_row][neighbor_col] != grid[row][col] and grid[neighbor_row][neighbor_col] != EMPTY and grid[neighbor_row][neighbor_col] != HIGHWAY):
                                bad_neighbors+=1
                            if grid[neighbor_row][neighbor_col] != EMPTY and grid[neighbor_row][neighbor_col] != HIGHWAY:
                                total_neighbors+=1
                if(not total_neighbors or bad_neighbors / total_neighbors > RELOCATION_THRESHOLD):
                    unhappy_agents.append((row,col))
            elif grid[row][col] == EMPTY: 
                empty_spots.append((row,col))
    return unhappy_agents, empty_spots

def relocate(grid_in, unhappy_in, empty_in):
   for agent in unhappy_in:
       destination = random.choice(empty_in)
       destination_r, destination_c = destination
       agent_r, agent_c = agent
       grid_in[destination_r][destination_c] = grid_in[agent_r][agent_c]
       grid_in[agent_r][agent_c] = EMPTY
       empty_in.remove(destination)
       empty_in.append(agent)

# --- HELPER: GENERATE BASE GRID ---
def generate_base_grid():
    """Generates a random grid WITHOUT a highway."""
    flat_grid = np.random.choice(
        [EMPTY, BLUE, RED],
        size = GRID_SIZE*GRID_SIZE,
        p=[EMPTY_HOUSE_RATIO, BLUE_EFFECTIVE_RATIO, RED_EFFECTIVE_RATIO]
    )
    return flat_grid.reshape(GRID_SIZE, GRID_SIZE)

# --- HELPER: APPLY HIGHWAY ---
def apply_highway(base_grid, highway_enabled):
    """Returns a COPY of the base grid with highway added if enabled."""
    grid_copy = base_grid.copy()
    if highway_enabled:
        for row in range(GRID_SIZE):
            grid_copy[row][49] = HIGHWAY
            grid_copy[row][50] = HIGHWAY
    return grid_copy

# --- INITIALIZATION ---

if 'base_grid' not in st.session_state:
    # 1. Create the permanent random seed grid
    st.session_state.base_grid = generate_base_grid()
    # 2. Create the display grid based on current highway setting
    st.session_state.grid = apply_highway(st.session_state.base_grid, use_highway)
    st.session_state.count = 0
    st.session_state.highway_setting = use_highway

# Logic to handle toggle changes without regenerating randomness
if st.session_state.highway_setting != use_highway:
    # User toggled highway -> Re-apply highway logic to the CLEAN base grid
    st.session_state.grid = apply_highway(st.session_state.base_grid, use_highway)
    st.session_state.count = 0
    st.session_state.highway_setting = use_highway
    st.rerun()

# --- APP LOGIC ---

col1, col2 = st.columns([3, 1])

with col2:
    if st.button("ðŸŽ² New Random Grid"):
        # Generate a brand new random seed
        st.session_state.base_grid = generate_base_grid()
        st.session_state.grid = apply_highway(st.session_state.base_grid, use_highway)
        st.session_state.count = 0
    
    run_simulation = st.button("â–¶ï¸ Run Simulation")
    status_text = st.empty()

with col1:
    plot_placeholder = st.empty()

# --- FAST RENDERER ---
def render_fast(grid):
    h, w = grid.shape
    img = np.zeros((h, w, 3), dtype=np.uint8)
    
    img[grid == EMPTY] = [255, 255, 255]    # White
    img[grid == BLUE] = [100, 149, 237]     # Cornflower Blue
    img[grid == RED] = [250, 128, 114]      # Salmon Red
    img[grid == HIGHWAY] = [211, 211, 211]  # Light Grey
    
    return img

plot_placeholder.image(render_fast(st.session_state.grid), use_container_width=True, width=500, caption="Grid State")
status_text.write(f"Iteration: {st.session_state.count}")

# --- SIMULATION LOOP ---

if run_simulation:
    continue_loop = True
    
    while continue_loop:
        st.session_state.count += 1
        
        unhappy, empty = identify(st.session_state.grid)
        
        if not unhappy:
            continue_loop = False
            st.success(f"Simulation finished after {st.session_state.count} iterations")
        else:
            status_text.write(f"Iteration: {st.session_state.count} | Unhappy agents: {len(unhappy)}")
            relocate(st.session_state.grid, unhappy, empty)
            
            plot_placeholder.image(render_fast(st.session_state.grid), use_container_width=True, width=500, caption="Grid State")
            
            if ANIMATION_SPEED > 0:
                time.sleep(ANIMATION_SPEED)